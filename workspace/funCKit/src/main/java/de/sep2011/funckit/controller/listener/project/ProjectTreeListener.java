/*
 * funCKit - functional Circuit Kit
 * Copyright (C) 2013  Lukas Elsner <open@mindrunner.de>
 * Copyright (C) 2013  Peter Dahlberg <catdog2@tuxzone.org>
 * Copyright (C) 2013  Julian Stier <mail@julian-stier.de>
 * Copyright (C) 2013  Sebastian Vetter <mail@b4sti.eu>
 * Copyright (C) 2013  Thomas Poxrucker <poxrucker_t@web.de>
 * Copyright (C) 2013  Alexander Treml <alex.treml@directbox.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

package de.sep2011.funckit.controller.listener.project;

import de.sep2011.funckit.controller.Controller;
import de.sep2011.funckit.controller.ImportWorker;
import de.sep2011.funckit.controller.ImportWorker.WorkerMode;
import de.sep2011.funckit.controller.listener.AbstractMouseListener;
import de.sep2011.funckit.model.graphmodel.Brick;
import de.sep2011.funckit.model.graphmodel.Circuit;
import de.sep2011.funckit.model.graphmodel.Component;
import de.sep2011.funckit.model.sessionmodel.EditPanelModel;
import de.sep2011.funckit.model.sessionmodel.Project;
import de.sep2011.funckit.util.Log;
import de.sep2011.funckit.util.internationalization.Language;
import de.sep2011.funckit.view.EditPanel;
import de.sep2011.funckit.view.ProjectTree;
import de.sep2011.funckit.view.View;
import de.sep2011.funckit.view.projecttreemodel.ProjectTreeBrickNode;
import de.sep2011.funckit.view.projecttreemodel.ProjectTreeComponentTypeNode;
import de.sep2011.funckit.view.projecttreemodel.ProjectTreeNode;
import de.sep2011.funckit.view.projecttreemodel.ProjectTreeNodeVisitor;
import de.sep2011.funckit.view.projecttreemodel.ProjectTreeProjectNode;
import de.sep2011.funckit.view.projecttreemodel.ProjectTreeRootNode;
import javax.swing.event.TreeExpansionEvent;
import javax.swing.event.TreeExpansionListener;
import javax.swing.event.TreeSelectionEvent;
import javax.swing.event.TreeSelectionListener;
import javax.swing.tree.TreePath;

import java.awt.Dimension;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseEvent;
import java.awt.geom.AffineTransform;
import java.awt.geom.Point2D;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.util.Deque;
import java.util.LinkedList;

import static de.sep2011.funckit.util.Log.gl;

/**
 * Listener that reacts on events generated by the {@link ProjectTree}.
 */
public class ProjectTreeListener extends AbstractMouseListener implements TreeSelectionListener,
        TreeExpansionListener, PropertyChangeListener, KeyListener {

    private final View view;
    private final Controller controller;
    private Project project;
    private final ProjectTree tree;

    /**
     * Constructor that expects the current {@link Controller} and {@link View}
     * reference.
     * 
     * @param controller
     *            Application controller object, should not be null
     * @param view
     *            associated View object, should not be null
     * @param tree
     *            The tree to listen to, not null
     */
    public ProjectTreeListener(View view, Controller controller, ProjectTree tree) {
        this.controller = controller;
        this.view = view;
        this.tree = tree;
    }

    @Override
    public void treeCollapsed(TreeExpansionEvent event) {
    }

    @Override
    public void treeExpanded(TreeExpansionEvent event) {
    }

    @Override
    public void valueChanged(TreeSelectionEvent event) {
        final ProjectTreeNode<?> selectedNode = (ProjectTreeNode<?>) tree
                .getLastSelectedPathComponent();

        if (selectedNode == null) {
            // nothing selected => return
            return;
        }

        /* build stack */
        final Deque<Component> stack = new LinkedList<Component>();
        final Project project = new ProjectTreeNodeVisitor() {

            Project project = null;

            {
                for (Object obj : tree.getSelectionPath().getPath()) {
                    ((ProjectTreeNode<?>) obj).accept(this);
                }
            }

            @Override
            public void visit(ProjectTreeComponentTypeNode node) {

            }

            @Override
            public void visit(ProjectTreeBrickNode node) {
                if (node.getContent() instanceof Component && node != selectedNode) {
                    stack.push((Component) node.getContent());
                }
            }

            @Override
            public void visit(ProjectTreeProjectNode node) {
                project = node.getContent();
            }

            @Override
            public void visit(ProjectTreeRootNode node) {

            }

            Project getProject() {
                return project;
            }
        }.getProject();

        new ProjectTreeNodeVisitor() {
            {
                selectedNode.accept(this);
            }

            @Override
            public void visit(ProjectTreeComponentTypeNode node) {

            }

            @Override
            public void visit(ProjectTreeBrickNode node) {
                projectedSelected(project);
                scrollBrickToVisible(tree.getSelectionPath());
            }

            @Override
            public void visit(ProjectTreeProjectNode node) {
                projectedSelected(node.getContent());
            }

            @Override
            public void visit(ProjectTreeRootNode node) {

            }
        };
    }

    private void scrollBrickToVisible(final TreePath path) {
        /* build stack */
        final Deque<Component> stack = new LinkedList<Component>();
        final ProjectTreeNode<?> selectedNode = (ProjectTreeNode<?>) path.getLastPathComponent();

        Brick selectedBrick;
        if (selectedNode instanceof ProjectTreeBrickNode) {
            selectedBrick = ((ProjectTreeBrickNode) selectedNode).getContent();
        } else {
            return;
        }

        Project project = new ProjectTreeNodeVisitor() {

            Project project = null;

            {
                for (Object obj : path.getPath()) {
                    ((ProjectTreeNode<?>) obj).accept(this);
                }
            }

            @Override
            public void visit(ProjectTreeComponentTypeNode node) {

            }

            @Override
            public void visit(ProjectTreeBrickNode node) {
                if (node.getContent() instanceof Component && node != selectedNode) {
                    stack.push((Component) node.getContent());
                }

            }

            @Override
            public void visit(ProjectTreeProjectNode node) {
                project = node.getContent();
            }

            @Override
            public void visit(ProjectTreeRootNode node) {

            }

            Project getProject() {
                return project;
            }
        }.getProject();

        /* get a corresponding Panel and its model, if there is none create one */
        EditPanel panel = null;
        EditPanelModel panelModel = null;
        while (panel == null) {
            for (EditPanel ep : view.getOpenEditPanels()) {
                if (ep.getPanelModel().getComponentStack().equals(stack)) {
                    panel = ep;
                    panelModel = ep.getPanelModel();
                    break;
                }
            }

            if (panel == null) {
                EditPanelModel tmpEpm = new EditPanelModel(stack.isEmpty() ? project.getCircuit()
                        : stack.peek().getType().getCircuit(), stack);
                project.addEditPanelModel(tmpEpm);
            }
        }

        if (panelModel == null) {
            return;
        }

        if (project.getSelectedEditPanelModel() != panelModel) {
            project.setSelectedEditPanelModel(panelModel);
        }

        Dimension panelSize = panel.getSize();
        Dimension brickDimension = selectedBrick.getDimension();

        AffineTransform trans = panelModel.getTransformation();
        double oldZoom = trans.getScaleX();
        panelModel.setZoom(1.0);

        double brickWidth = brickDimension.width;
        double brickHeight = brickDimension.height;

        Point2D brickCenter = new Point2D.Double(selectedBrick.getPosition().x + brickWidth / 2.0,
                selectedBrick.getPosition().y + brickHeight / 2.0);

        panelModel.setCenter(panelSize.width / 2.0, panelSize.height / 2.0);

        panelModel.setTranslationX(brickCenter.getX() - panelSize.width / 2.0);
        panelModel.setTranslationY(brickCenter.getY() - panelSize.height / 2.0);

        panelModel.setZoom(oldZoom);

        panelModel.setActiveBrick(selectedBrick);

    }

    private void projectedSelected(Project selectedProject) {
        if (selectedProject.getCircuit() == null) {
            return;
        }
        if (view.getSessionModel().getCurrentProject() != selectedProject) {
            gl().debug("Switching project...");
            view.getSessionModel().setCurrentProject(selectedProject);
        }

        if (selectedProject.hasSimulation()) {
            controller.enterSimulationMode();
        } else {
            EditPanelModel panelModel = selectedProject.getSelectedEditPanelModel();
            controller.enterEditMode(panelModel != null && panelModel.hasMainCircuit());
        }
    }

    private void loadCircuit(String path) {
        if (path == null || path.equals("")) {
            view.showErrorMessage(Language.tr("project.emptyProjectPath.title"),
                    Language.tr("project.emptyProjectPath.message"));
            return;
        }
        File file = new File(path);
        if (!file.canRead()) {
            view.showErrorMessage(Language.tr("project.invalidProjectPath.title"),
                    Language.tr("project.invalidProjectPath.message", path));
            return;
        }

        ImportWorker importWorker;
        try {
            importWorker = new ImportWorker(view, new FileInputStream(file), WorkerMode.CIRCUIT);
        } catch (FileNotFoundException e) {
            view.showErrorMessage(Language.tr("project.invalidProjectPath.title"),
                    Language.tr("project.invalidProjectPath.message", path));
            return;
        }

        importWorker.addPropertyChangeListener(this);
        view.setStatusText(Language.tr("status.loadingData"));
        gl().debug("Starting to load project from tree...");
        view.prepareProgress(file.getName());
        importWorker.execute();

        // blocks while importing through only showing the modal progressbar
        // dialog
        view.showProgress();
    }

    @Override
    public void propertyChange(PropertyChangeEvent evt) {
        String property = evt.getPropertyName();
        if (property.equals("progress")) {
            view.setProgress((Integer) evt.getNewValue());
        } else if (property.equals("dataClose")) {
            view.setStatusText(Language.tr("status.loadingImport"));
        } else if (property.equals("result")) {
            project.setCircuit((Circuit) evt.getNewValue());
            Log.gl().debug("Circuit with " + project.getCircuit().getElements().size() + "Elements loaded");
            // } else if (property.equals("converted")) {
            // SEPFormatConverter converter = (SEPFormatConverter)
            // evt.getNewValue();
            // project.setName(converter.getProjectName());
        }
    }

    @Override
    public void mouseClicked(final MouseEvent event) {
        final TreePath path = tree.getPathForLocation(event.getX(), event.getY());

        if (path == null) {
            return;
        }

        final ProjectTreeNode<?> lastNode = (ProjectTreeNode<?>) path.getLastPathComponent();

        new ProjectTreeNodeVisitor() {

            {
                lastNode.accept(this);
            }

            @Override
            public void visit(ProjectTreeComponentTypeNode node) {

            }

            @Override
            public void visit(ProjectTreeBrickNode node) {
            }

            @Override
            public void visit(ProjectTreeProjectNode node) {
                if (event.getClickCount() == 2) {
                    openUnloadedProject(node.getContent());
                }
            }

            @Override
            public void visit(ProjectTreeRootNode node) {

            }
        };

    }

    @Override
    public void keyTyped(KeyEvent e) {

    }

    @Override
    public void keyPressed(KeyEvent e) {
        switch (e.getKeyCode()) {
        case KeyEvent.VK_ENTER:
            final ProjectTreeNode<?> selectedNode = (ProjectTreeNode<?>) tree
                    .getLastSelectedPathComponent();

            if (selectedNode == null) {
                // nothing selected => return
                return;
            }

            new ProjectTreeNodeVisitor() {
                {
                    selectedNode.accept(this);
                }

                @Override
                public void visit(ProjectTreeComponentTypeNode node) {

                }

                @Override
                public void visit(ProjectTreeBrickNode node) {

                }

                @Override
                public void visit(ProjectTreeProjectNode node) {
                    openUnloadedProject(node.getContent());
                }

                @Override
                public void visit(ProjectTreeRootNode node) {

                }
            };

            break;
        }

    }

    private void openUnloadedProject(Project pro) {
        if (pro.getCircuit() == null) {

            // try to load project
            project = pro;
            loadCircuit(pro.getAbsolutePath());
            controller.openMainCircuitTab(project);
            projectedSelected(pro);
        }
    }

    @Override
    public void keyReleased(KeyEvent e) {
        switch (e.getKeyCode()) {
        case KeyEvent.VK_DELETE:

            final ProjectTreeNode<?> selectedNode = (ProjectTreeNode<?>) tree
                    .getLastSelectedPathComponent();

            if (selectedNode == null) {
                // nothing selected => return
                return;
            }

            new ProjectTreeNodeVisitor() {
                {
                    selectedNode.accept(this);
                }

                @Override
                public void visit(ProjectTreeComponentTypeNode node) {

                }

                @Override
                public void visit(ProjectTreeBrickNode node) {

                }

                @Override
                public void visit(ProjectTreeProjectNode node) {
                    switch (view.getSessionModel().getViewType()) {
                    case VIEW_TYPE_STANDALONE:
                        DeleteProjectActionListener.deleteProject(node.getContent(), view, controller);
                        break;
                    }
                }

                @Override
                public void visit(ProjectTreeRootNode node) {

                }
            };

            break;

        default:
            break;
        }

    }

}
